<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Linked List Algorithm and Analysis</title>

  <style>
    body{
      font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }
    .home{
      max-width: 1300px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      text-align: center;
      color: #333;
    }
    p {
      text-align: justify;
      line-height: 1.6;
    }
    pre {
      background-color: #e0e0e0;
      padding: 15px;
      border-radius: 5px;
      max-width: 90%;
      margin: 20px auto;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, 'Courier New', monospace;
    }
    .analysis {
      background-color: #ecf0f1;
      padding: 20px;
      margin: 20px auto;
      border-left: 5px solid #3498db;
      max-width: 90%;
    }
    .center {
      text-align: center;
    }
    img {
      max-width: 50%;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>

  <div class="home">
    <h1>Linked List Algorithm and Analysis</h1>

    <h2>Algorithm Overview</h2>
    <p>A linked list is a linear data structure where each element (node) is a separate object. Each node comprises two fields: data and a reference (or pointer) to the next node in the sequence. Linked lists are dynamic and allow efficient insertion and deletion of elements. Below are the algorithms for inserting and deleting nodes in a singly linked list.</p>

    <h2>Algorithm: Insertion at the Beginning</h2>
    <h3>Theory</h3>
    <p>Inserting a node at the beginning of a linked list involves creating a new node and updating the head pointer. The new node becomes the head of the list, and its next pointer points to the old head. This operation is efficient because it does not require traversing the list, making it a constant-time operation.</p>

    <pre><code>
// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert a new node at the beginning
void insertAtBeginning(struct Node** head, int newData) {
    // 1. Allocate memory for the new node
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

    // 2. Assign data to the new node
    newNode->data = newData;

    // 3. Make next of new node as head
    newNode->next = *head;

    // 4. Move the head to point to the new node
    *head = newNode;
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Insertion Algorithm</h3>
      <p><strong>Best Case:</strong> O(1) — The operation always takes constant time, as we only need to modify the head pointer and create a new node.</p>
      <p><strong>Average Case:</strong> O(1) — There is no traversal required, so the average time complexity is constant.</p>
      <p><strong>Worst Case:</strong> O(1) — Even in the worst-case scenario (with a large list), the insertion at the beginning remains a constant-time operation.</p>
      <p><strong>Space Complexity:</strong> O(1) — The space complexity per operation is constant because only one new node is created.</p>
    </div>

    <h2>Algorithm: Deletion from the Beginning</h2>
    <h3>Theory</h3>
    <p>Deleting a node from the beginning of a linked list involves updating the head pointer to the next node and freeing the memory of the original head node. Like insertion, deletion at the beginning is a simple and efficient operation that does not require list traversal, making it a constant-time operation.</p>

    <pre><code>
// Function to delete a node from the beginning
void deleteAtBeginning(struct Node** head) {
    if (*head == NULL) return; // List is empty

    // 1. Store the current head node in a temp variable
    struct Node* temp = *head;

    // 2. Move head to point to the next node
    *head = (*head)->next;

    // 3. Free memory of the old head
    free(temp);
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Deletion Algorithm</h3>
      <p><strong>Best Case:</strong> O(1) — Deleting the first node always takes constant time, regardless of the size of the list.</p>
      <p><strong>Average Case:</strong> O(1) — Since no traversal is required, the average time complexity remains constant.</p>
      <p><strong>Worst Case:</strong> O(1) — The time complexity does not increase even in the worst case, making it constant-time.</p>
      <p><strong>Space Complexity:</strong> O(1) — The space complexity is constant because we only free one node's memory.</p>
    </div>

    <h2>Visual Representation of a Singly Linked List</h2>
    <img src="https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg" alt="Singly Linked List" class="center">

  </div>

</body>
</html>
