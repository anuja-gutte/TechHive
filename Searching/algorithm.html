<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Search Algorithms and Analysis</title>

  <style>
    body{
      font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }
    .home{
      max-width: 1300px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      text-align: center;
      color: #333;
    }
    p {
      text-align: justify;
      line-height: 1.6;
      font-size: large;
    }
    pre {
      background-color: #e0e0e0;
      padding: 15px;
      border-radius: 5px;
      max-width: 90%;
      margin: 20px auto;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, 'Courier New', monospace;
    }
    .analysis {
      background-color: #ecf0f1;
      padding: 20px;
      margin: 20px auto;
      border-left: 5px solid #3498db;
      max-width: 90%;
    }
    .center {
      text-align: center;
    }
    img {
      max-width: 50%;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>

  <div class="home">
    <h1>Search Algorithms and Analysis</h1>

    <h2>Algorithm Overview</h2>
    <p>Searching is a fundamental operation in computer science used to locate an element in a list or array. The two primary searching techniques are linear search and binary search. Each algorithm has its specific use cases, depending on whether the data is sorted or unsorted, as well as the size of the data.</p>

    <h2>Algorithm: Linear Search</h2>
    <h3>Theory</h3>
    <p>Linear search is a simple algorithm that checks each element of the list one by one until the desired element is found or the list ends. This method works on both sorted and unsorted lists but is inefficient for large datasets as it has a time complexity of O(n).</p>

    <pre><code>
// Function for linear search
int linearSearch(int arr[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == x) {
            return i; // Element found, return its index
        }
    }
    return -1; // Element not found
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Linear Search Algorithm</h3>
      <p><strong>Best Case:</strong> O(1) — The element is at the beginning of the list.</p>
      <p><strong>Average Case:</strong> O(n) — On average, the algorithm needs to search half of the elements.</p>
      <p><strong>Worst Case:</strong> O(n) — The element is at the end of the list or not present.</p>
      <p><strong>Space Complexity:</strong> O(1) — Constant space is used since the search is conducted in-place.</p>
    </div>

    <h2>Algorithm: Binary Search</h2>
    <h3>Theory</h3>
    <p>Binary search is a much faster algorithm than linear search, but it requires the list to be sorted. It works by repeatedly dividing the list into halves and comparing the middle element with the target value. If the target is smaller, the search continues in the left half, otherwise, it continues in the right half. This algorithm has a logarithmic time complexity of O(log n).</p>

    <pre><code>
// Function for binary search
int binarySearch(int arr[], int n, int x) {
    int low = 0;
    int high = n - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid] == x) {
            return mid;
        }

        // If x greater, ignore the left half
        if (arr[mid] < x) {
            low = mid + 1;
        }
        // If x is smaller, ignore the right half
        else {
            high = mid - 1;
        }
    }
    return -1; // Element not found
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Binary Search Algorithm</h3>
      <p><strong>Best Case:</strong> O(1) — The element is at the middle of the list in the first iteration.</p>
      <p><strong>Average Case:</strong> O(log n) — The algorithm reduces the search space by half each time.</p>
      <p><strong>Worst Case:</strong> O(log n) — The search continues until only one element is left.</p>
      <p><strong>Space Complexity:</strong> O(1) — The iterative version of binary search uses constant space.</p>
    </div>

    <h2>Visual Representation of Search Algorithms</h2>
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_search_algorithm_diagram.svg" alt="Binary Search Diagram" class="center">

  </div>

</body>
</html>
