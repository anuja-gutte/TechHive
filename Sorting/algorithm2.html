<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sorting Algorithms and Analysis</title>

  <style>
    body{
      font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }
    .home{
      max-width: 1300px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      text-align: center;
      color: #333;
    }
    p {
      text-align: justify;
      line-height: 1.6;
      font-size: large;
    }
    pre {
      background-color: #e0e0e0;
      padding: 15px;
      border-radius: 5px;
      max-width: 90%;
      margin: 20px auto;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, 'Courier New', monospace;
    }
    .analysis {
      background-color: #ecf0f1;
      padding: 20px;
      margin: 20px auto;
      border-left: 5px solid #3498db;
      max-width: 90%;
    }
    .center {
      text-align: center;
    }
    img {
      max-width: 50%;
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>

  <div class="home">
    <h1>Sorting Algorithms and Analysis</h1>

    <h2>Algorithm Overview</h2>
    <p>Sorting algorithms are essential for organizing data in a specific order (ascending or descending). This improves search efficiency and readability. Two important sorting techniques are insertion sort and merge sort. Each algorithm has its strengths based on the input size and characteristics.</p>

    <h2>Algorithm: Insertion Sort</h2>
    <h3>Theory</h3>
    <p>Insertion sort is a simple, intuitive sorting algorithm that builds the sorted list one item at a time. It iterates over the array, growing the sorted portion by inserting each new element into its proper position. Although it is efficient for small datasets, its time complexity for larger datasets is not ideal.</p>

    <pre><code>
// Function for insertion sort
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        // Move elements of arr[0..i-1] that are greater than key
        // to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Insertion Sort Algorithm</h3>
      <p><strong>Best Case:</strong> O(n) — When the array is already sorted.</p>
      <p><strong>Average Case:</strong> O(n<sup>2</sup>) — On average, elements are compared with half of the sorted portion.</p>
      <p><strong>Worst Case:</strong> O(n<sup>2</sup>) — If the array is sorted in reverse order.</p>
      <p><strong>Space Complexity:</strong> O(1) — The algorithm is in-place and requires no additional memory.</p>
      <p>Insertion sort is adaptive, making it a good choice for small or nearly sorted arrays, as it requires fewer comparisons and swaps.</p>
    </div>

    <h2>Algorithm: Merge Sort</h2>
    <h3>Theory</h3>
    <p>Merge sort is a divide-and-conquer algorithm that recursively divides the array into two halves, sorts them, and then merges the sorted halves. Merge sort is more efficient for larger datasets due to its logarithmic time complexity. Unlike insertion sort, it requires additional memory for merging.</p>

    <pre><code>
// Function for merge sort
void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp arrays
    int L[n1], R[n2];

    // Copy data to temp arrays
    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        // Merge the sorted halves
        merge(arr, l, m, r);
    }
}
    </code></pre>

    <div class="analysis">
      <h3>Analysis: Merge Sort Algorithm</h3>
      <p><strong>Best Case:</strong> O(n log n) — The algorithm always divides the array and merges it back together in logarithmic time.</p>
      <p><strong>Average Case:</strong> O(n log n) — The time complexity remains the same across all cases.</p>
      <p><strong>Worst Case:</strong> O(n log n) — Even in the worst case, merge sort still has a logarithmic time complexity.</p>
      <p><strong>Space Complexity:</strong> O(n) — Merge sort requires additional space for temporary arrays during the merge process.</p>
      <p>Merge sort is stable, which means that equal elements retain their original order. This makes it a reliable choice for large datasets and for situations where stability is important.</p>
    </div>

    <h2>Visual Representation of Sorting Algorithms</h2>
    <img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="Merge Sort Visualization" class="center">

  </div>

</body>
</html>
